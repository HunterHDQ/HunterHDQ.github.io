<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[团建后的一点心情]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%9B%A2%E5%BB%BA%E5%90%8E%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E6%83%85%2F</url>
    <content type="text"><![CDATA[2019-1-19 随笔2019-1-19，公司集体组织团建，无非就是一伙人找个地方，吃吃饭，聊聊天，唱唱歌，玩玩游戏，本就是抱着吃一顿饭就回来的心态去的。从早上八点出发到晚上八点回来，团建总体来说很热闹，在一个别墅里面（电竞VR体验馆）30多个人，很久没有这么多人在一起了。 回来之后，突然有一种感觉：觉得生活很无趣甚至讨厌这个浮躁的社会。可能是一下子从热闹的场景里面回到了一个人空荡的房间，孤独寂寞的感觉充斥着整个人。我以为只有我一个人有这样的想法，于是问了年长我几岁的朋友，发现他也会有这样的感觉，这样确定下来我是正常的。 2019年是崭新的一年，我静着坐下来回想了一下2018年的所得与所失。人生中在某些时候有很多种选择，不论是深造，公务员，继续工作，或者是转行创业，还是在疲惫后来一场“酣畅淋漓”的旅行，选择背后都需要付出巨大的努力。小时候会盼着快快长大于是浑浑噩噩的过日子，转眼间二十多岁又会有所恐慌，才发现时间过的如此之快，很快就会往三十上爬，很害怕到那个时候自己还是个碌碌无为的人（可能是忧虑的过早）。这个时代的年轻人背负了太多的压力，太多的责任，我们奋斗想过上更好的生活，想体现自己的价值。然而社会在有些时候却渐渐扭曲了我们的价值观，人们为着房子一生背上了沉重的房贷，为了一套房子不断去想着办法挣钱，好似大部分人都为了“钱”奋斗，现实让我们一个个成为痛苦的房奴，但却还是不断地有人去做“奴隶”。 自己觉得自己还算是个低调谦逊的人，同样自始至终都不是一个善于表达想法的人，总是习惯将一些想法藏在心里，然后通过努力一点一点去实现，成功了也就成功了也没有多少人为你喝彩，不成功那就是失败了自然也没有多少人嘲笑你。时间长了之后，可能已经没有多少人记得你了。我从来都不想在合适的时候表现自己，其实默默按着自己的想法去干一件事情挺好的，做一只小蚂蚁不亮眼，不会被大象踩死，一点点“搬运”，也会充实整个“蚂蚁家族”。我始终相信那些支持你的那些属于你的会始终在你身边，这二十多年来，觉得自己从一个“感性”的小伙逐渐变得“理性”“成熟”，再也不会依着自己的性情来做事。 今天偶然看到一篇微信推文：孤独，是人生的必修课。《百年孤独》里说：“生命从来不曾离开过孤独而独立存在。无论是我们出生、我们成长、我们相爱还是我们成功失败，直到最后的最后，孤独犹如影子一样存在于生命一隅。” 现在听着逃跑计划的《一万次悲伤》：一万次悲伤，依然会有dream，我一直在最温暖的地方等你，似乎只能这样，停留一个方向，已不能改变，每一颗眼泪，是一万道光，最昏暗的地方也变得明亮，我奔涌的暖流寻找你的海洋，我注定这样。已是23点20分，看看书，去睡觉。明天起来又会是崭新的一天。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer、StringBuilder的区别]]></title>
    <url>%2F2018%2F05%2F31%2FString%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[基本回答String是Java语言中非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是final class，即Immutable类，其所有属性都被声明为final，所以我们对String的拼接和截取等都会产生新的String对象。日常开发中，对于字符串的操作会非常多，那么String的相关操作往往会对应用性能产生明显的影响。 StringBuffer是为了解决String字符串拼接操作产生太多中间对象而提供的一个类，StringBuffer有很多方法供我们操作字符串，例如appen方法追加字符，insert方法在指定位置插入字符。它的本质是一个线程安全的可修改的字符序列，但是保证线程安全也会带来额外的性能开销，除非有线程安全的必要，否则推荐使用StringBuilder。 StringBuilder是jdk1.5中增加的，它的功能和StringBuffer没有什么区别，但是它不是线程安全的，减少了一些额外的开销，在大部分情况下我们都用它来对字符串拼接等操作。 一点拓展String是Immutable类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改。StringBuffer实现线程安全是在所有的修改数据的方法上加上synchronized关键字，简单粗暴。StringBuffer和StringBuilder本质上是privata final char[] value数组（JDK9中为byte)，二者都继承了AbstractStringBuilder，区别仅在与在方法上是否添加了synchronized关键字。Java字符串的设计者在最初就考虑到了char类型的内部数组应该创建多大最为合适。过小会导致字符串操作时会重新创建足够大的数组，过大的话就会浪费空间。目前，构建时初始长度为16，这样的大小是被认为是最合适的，避免很多次扩容产生的额外开销。扩容实际上抛弃原有数组，创建新的数组（可简单认为是倍数扩容），然后进行arraycopy。 关于String的创建机制有必要做更深层次的探究：由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。 12举例：String str1 = "123"; //通过直接量赋值方式，放入字符串常量池String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池 注意：String提供了intern()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。在java6历史版本中，Intern缓存的字符串存在于“永久代”中，这个空间是有限的，也基本不会被FULLGC之外的垃圾收集照顾到，如果调用太多，就会出现OOM错误。再后来的版本中，缓存被放到了堆中，避免了永久代被占满的问题，并且JDK1.8中永久代被MetaSpace（元数据区）替代。 应用场景①在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。 ②在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。 ③在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final、finally、finalize有什么不同]]></title>
    <url>%2F2018%2F05%2F16%2Ffinal%E3%80%81finally%E3%80%81finalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[基本回答1.final可以用来修饰类、方法和变量。final修饰的类不可以被继承，修饰的变量不可以被修改，修饰的方法不可以被重写(Overwrite)。 2.finally表示Java保证重点代码一定要执行的一种机制。通常开发中，我们使用try-finally或者try-catch-finally来执行一些特定的操作，比如关闭JDBC的连接，关闭IO流、保证unlock锁等。 3.finalize是Java lang包下基础类Object的一个方法，它是为了保证对象在被GC前完成特定资源的回收。在jdk9中已被deprecated，不推荐使用。 一点拓展​ final是被推荐使用的，它可以明确地表示我们代码的逻辑意图，明确告知别人某些行为是不可以更改的。在java.lang包下的很多类都被声明为final class，有效避免API使用者更改基础功能，保证平台安全。使用final修饰参数或变量，可以避免意外赋值导致的编程bug。并且final变量可以用于保护只读数据，在并发编程中，明确不能再赋值final变量，有利于减少额外的同步开销，省去一些防御性拷贝的必要。那么final是不是immutable（不可变）呢？其实不然。 12345final ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("single"); list.add("dog"); list.add("is pretty good"); System.out.println(list); final约束的是list这个引用不可以被赋值，但是这个对象的行为不受final影响，不论是添加还是删除元素都是可以的。 ​ finally相信每一个Java开发者都知道怎么使用。其实在jdk7的版本就推出了try-catch-resources，我们可以使用它来更好地处理异常，减少我们一些重复的关闭资源的动作。特别要注意的是，finally里的代码在有一种情况下不会执行： 123456try&#123; ... System.exit(1);&#125;finally&#123; ...&#125; ​ finalize业界不推荐使用，我们无法使用finalize保证特定资源的回收，finalize具体在什么时候执行，是否符合我们的需求这些都是无法预知的。使用不当会导致程序死锁等。finalize是被设计在对象被垃圾收集前调用，那么JVM需要对finalize方法的对象进行额外的处理，本质上是快速回收的障碍者，可能导致你的对象经过多个垃圾收集周期才被回收。finalize拖慢垃圾回收，导致大量对象堆积，进一步导致OOM错误。所以资源用完就显式释放，或利用资源池来尽量reuse。目前Java正在用Cleaner来代替finalize，笔者能力有限，这里不做多说，有兴趣的可以多了解。]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说对于Java的理解]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B4%E8%AF%B4%E5%AF%B9%E4%BA%8EJava%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[基本回答​ Java是一门面向对象的语言，它主要有两个重要的特性。一是优秀的跨平台能力，就如官方所说的”write once,run anywhere”（书写一次，到处运行），二是Java中的GC(Garbage Collection)机制,Java通过垃圾收集器（Garbage Collector）回收分配内存，一般情况下，程序员不需要自己关心内存的分配和回收。 ​ 同时，Java日常开发中最常用到的就是JDK和JRE。其中JRE即Java的运行环境，包含了JVM和Java的类库等，JDK包括了JRE，它相比JRE提供了更多的工具，如编译器，Jconsole… ​ Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。​ 严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。“一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。Java虚拟机和DOS类似，相当于一个供程序运行的平台。“到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。 一点拓展​ 日常开发中，我们的Java代码会通过Javac编译成字节码，运行时，通过JVM内嵌的解释器将字节码转换成为最后的机器码。 ​ 在我们大部分开发中用的JVM中，Oracle JDK 提供的 Hotspot JVM，都提供JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，能将运行时的一部分热点代码翻译成机器码（编译执行），所以Java并不完全是解释执行的语言。 ​ Java在编译期生成.class文件，通过JVM和字节码屏蔽了操作系统和硬件的细节。在运行时通过class-loader加载字节码，解释或编译执行，在JDK1.8中就是解释和编译混合的模式（-Xmixed）。 ​ 下图是摘自极客时间@Java核心技术36讲 杨晓峰前Oracle首席工程师总结的Java平台相对宽泛的蓝图： 大家可以据此更深层次的了解Java这门古老的语言。]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>Java面试</tag>
      </tags>
  </entry>
</search>

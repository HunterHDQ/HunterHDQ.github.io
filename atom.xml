<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hunter的博客</title>
  
  <subtitle>Technology-driven life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hunterhdq.github.io/"/>
  <updated>2019-01-28T14:01:07.280Z</updated>
  <id>https://hunterhdq.github.io/</id>
  
  <author>
    <name>Hunter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Service Discovery</title>
    <link href="https://hunterhdq.github.io/2019/01/28/Service-Discovery/"/>
    <id>https://hunterhdq.github.io/2019/01/28/Service-Discovery/</id>
    <published>2019-01-28T13:45:49.000Z</published>
    <updated>2019-01-28T14:01:07.280Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>In any distributed architecture, we need to find the physical address of where a<br>machine is located. This concept has been around since the beginning of distributed computing and is known formally as service discovery. Service discovery can be something as simple as maintaining a property file with the addresses of all the remote services used by an application, or something as formalized (and complicated) as a  UDDI (Universal Description, Discovery, and Integration) repository. <a id="more"></a> </p><p>Service discovery is critical to microservice, cloud-based applications for two key<br>reasons. First, it offers the application team the ability to quickly horizontally scale up and down the number of service instances running in an environment. The service consumers are abstracted away from the physical location of the service via service discovery. Because the service consumers don’t know the physical location of the actual service instances, new service instances can be added or removed from the pool of available services.</p><p>This ability to quickly scale services without disrupting the service consumers is an extremely powerful concept, because it moves a development team used to building monolithic, single-tenant (for example, one customer) applications away from thinking about scaling only in terms of adding bigger, better hardware (vertical scaling) to the more powerful approach to scaling by adding more servers (horizontal scaling).<br>A monolithic approach usually drives development teams down the path of over-<br>buying their capacity needs. Capacity increases come in clumps and spikes and arerarely a smooth steady path. Microservices allow us to scale up/down new serviceinstances. Service discovery helps abstract that these deployments are occurring away from the service consumer.<br>The second benefit of service discovery is that it helps increase application resil-iency. When a microservice instance becomes unhealthy or unavailable, most service discovery engines will remove that instance from its internal list of available services.The damage caused by a down service will be minimized because the service discovery engine will route services around the unavailable service.</p><h3 id="Traditional-Service-Location-Resolution"><a href="#Traditional-Service-Location-Resolution" class="headerlink" title="Traditional Service Location Resolution"></a>Traditional Service Location Resolution</h3><p><img src="/images/springmicroservices/springmicroc4p1.png" alt="springmicroc4p1"></p><p>In the cloud where you have to deal with massive amounts of transac-<br>tions and redundancy, a centralized piece of network infrastructure doesn’t ulti-<br>mately work as well because it doesn’t scale effectively and isn’t cost-efficient.</p><h3 id="On-service-discovery-in-the-cloud"><a href="#On-service-discovery-in-the-cloud" class="headerlink" title="On service discovery in the cloud"></a>On service discovery in the cloud</h3><p>The solution for a cloud-based microservice environment is to use a service-discovery mechanism that’s<br> Highly available—Service discovery needs to be able to support a “hot” clustering environment where service lookups can be shared across multiple nodes in a service discovery cluster. If a node becomes unavailable, other nodes in the cluster should be able to take over.<br> Peer-to-peer—Each node in the service discovery cluster shares the state of a service instance.<br> Load balanced—Service discovery needs to dynamically load balance requests across all service instances to ensure that the service invocations are spread across all the service instances managed by it. In many ways, service discovery replaces the more static, manually managed load balancers used in many early web application implementations.<br> Resilient—The service discovery’s client should “cache” service information locally. Local caching allows for gradual degradation of the service discovery feature so that if service discovery service does become unavailable, applications can still function and locate the services based on the information maintained in its local cache.<br> Fault-tolerant—Service discovery needs to detect when a service instance isn’t healthy and remove the instance from the list of available services that can take client requests. It should detect these faults with services and take action without human intervention.</p><h4 id="The-architecture-of-service-discovery"><a href="#The-architecture-of-service-discovery" class="headerlink" title="The architecture of service discovery"></a>The architecture of service discovery</h4><p>To begin our discussion around service discovery architecture, we need to understand<br>four concepts. These general concepts are shared across all service discovery implementations:<br> Service registration—How does a service register with the service discovery agent?<br> Client lookup of service address—What’s the means by which a service client looks up service information?<br> Information sharing—How is service information shared across nodes?<br> Health monitoring—How do services communicate their health back to the service discovery agent?</p><p><img src="/images/springmicroservices/springmicroc4p2.png" alt="springmicroc4p2"></p><p>As service instances start up, they’ll register their physical location, path, and port that they can be accessed by with one or more service discovery instances. While each instance of a service will have a unique  IP address and port, each service instance that comes up will register under the same service  ID . A service  ID is nothing more than a key that uniquely identifies a group of the same service instances.</p><p>A service will usually only register with one service discovery service instance. Most service discovery implementations use a peer-to-peer model of data propagation where the data around each service instance is communicated to all the other nodes in the cluster.</p><p>Depending on the service discovery implementation, the propagation mechanism<br>might use a hard-coded list of services to propagate to or use a multi-casting protocol like the “gossip” 2 or “infection-style” 3 protocol to allow other nodes to “discover” changes in the cluster.<br>Finally, each service instance will push to or have pulled from its status by the service discovery service. Any services failing to return a good health check will be removed from the pool of available service instances.</p><p>Once a service has registered with a service discovery service, it’s ready to be used<br>by an application or service that needs to use its capabilities. Different models exist for a client to “discover” a service. A client can rely solely on the service discovery engine to resolve service locations each time a service is called. With this approach, the service discovery engine will be invoked every time a call to a registered microservice instance is made. Unfortunately, this approach is brittle because the service client is completely dependent on the service discovery engine to be running to find and invoke a service.<br>A more robust approach is to use what’s called client-side load balancing. Figure4.3 illustrates this approach.</p><p><img src="/images/springmicroservices/springmircroc4p3.png" alt="springmircroc4p3"></p><h4 id="Service-discovery-in-action-using-Spring-and-Netflix-Eureka"><a href="#Service-discovery-in-action-using-Spring-and-Netflix-Eureka" class="headerlink" title="Service discovery in action using Spring and Netflix Eureka"></a>Service discovery in action using Spring and Netflix Eureka</h4><p>Spring Cloud offers multiple methods for looking up information from a service discovery agent.Once again, the Spring Cloud project makes this type of setup trivial to undertake.You’ll use Spring Cloud and Netflix’s Eureka service discovery engine to implement your service discovery pattern. For the client-side load balancing you’ll use Spring Cloud and Netflix’s Ribbon libraries.</p><p><img src="/images/springmicroservices/springmicroc4p4.png" alt="springmicroc4p4"></p><p>1 As the services are bootstrapping, the licensing and organization services will<br>also register themselves with the Eureka Service. This registration process will<br>tell Eureka the physical location and port number of each service instance along with a service  ID for the service being started.<br>2 When the licensing service calls to the organization service, it will use the Netflix Ribbon library to provide client-slide load balancing. Ribbon will contact the Eureka service to retrieve service location information and then cache it locally.<br>3 Periodically, the Netflix Ribbon library will ping the Eureka service and refresh<br>its local cache of service locations.</p><p>Any new organization services instance will now be visible to the licensing service locally, while any non-healthy instances will be removed from the local cache.</p><h3 id="Building-Spring-Eureka-Service"><a href="#Building-Spring-Eureka-Service" class="headerlink" title="Building Spring Eureka Service"></a>Building Spring Eureka Service</h3><p>The following listing shows the Eureka service dependencies you’ll need for the Spring Boot project you’re setting up.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;Finchley.SR1&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>You’ll then need to set up the src/main/resources/application.yml file with the configuration needed to set up the Eureka service running in standalone mode (for example, no other nodes in the cluster), as shown in the next listing.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  #Port Eureka Serveris going to listen on</span><br><span class="line">  port: <span class="number">8761</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    #Don’t register with Eureka service.</span><br><span class="line">    registerWithEureka: <span class="keyword">false</span></span><br><span class="line">    #Don’t cache registry information locally.</span><br><span class="line">    fetchRegistry: <span class="keyword">false</span></span><br><span class="line">    serviceUrl:</span><br><span class="line">          defaultZone: http:<span class="comment">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">  server:</span><br><span class="line">     #Initial time to wait before server takes requests</span><br><span class="line">     waitTimeInMsWhenSyncEmpty: <span class="number">5</span> </span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eurka-server</span><br></pre></td></tr></table></figure><p>The key properties being set are the  server.port attribute that sets the default port used for the Eureka service. The  eureka.client.registerWithEureka attribute<br>tells the service not to register with a Eureka service when the Spring Boot Eureka application starts because this is the Eureka service. The  eureka.client<br>.fetchRegistry attribute is set to false so that when the Eureka service starts, it<br>doesn’t try to cache its registry information locally. When running a Eureka client,you’ll want to change this value for the Spring Boot services that are going to register with Eureka.</p><p>You’ll notice that the last attribute,  eureka.server.waitTimeInMsWhenSync<br>Empty , is commented out. When you’re testing your service locally you should uncomment this line because Eureka won’t immediately advertise any services that register with it. It will wait five minutes by default to give all of the services a chance to register with it before advertising them. Uncommenting this line for local testing will help speed up the amount of time it will take for the Eureka service to start and show services registered with it.</p><p>Individual services registering will take up to 30 seconds to show up in the Eureka<br>service because Eureka requires three consecutive heartbeat pings from the service spaced 10 seconds apart before it will say the service is ready for use. Keep this in mind as you’re deploying and testing your own services.</p><p>The last piece of setup work you’re going to do in setting up your Eureka service is adding an annotation to the application bootstrap class you’re using to start your Eureka service.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//Enable Eureka server in the Spring service</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FristeurekaApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(FristeurekaApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At this point you can start up the Eureka service by running the  mvn springboot:run or run  docker-compose  to start the service.</p><h3 id="Registering-services-with-Spring-Eureka"><a href="#Registering-services-with-Spring-Eureka" class="headerlink" title="Registering services with Spring Eureka"></a>Registering services with Spring Eureka</h3><p>Registering a Spring Boot-based microservice with Eureka is an extremely simple<br>exercise.The first thing you need to do is add the Spring Eureka dependency to your client’s  service’s pom.xml file:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Modifying your client service’s application.yml to talk to Eureka:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8765</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">  #Register the IP of the service rather than the server name.</span><br><span class="line">    prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">     #Location of the Eureka Service</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8761/eureka/</span></span><br><span class="line">    #Register the service with Eureka.</span><br><span class="line">    register-with-eureka: <span class="keyword">true</span></span><br><span class="line">    #Pull down a local copy of the registry</span><br><span class="line">    fetch-registry: <span class="keyword">true</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    #Logical name of the service that will be registered with Eureka</span><br><span class="line">    name: eureka-client</span><br><span class="line">  profiles:</span><br><span class="line">    active: <span class="keyword">default</span></span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      enabled: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>Every service registered with Eureka will have two components associated with it: the application  ID and the instance  ID . The application  ID is used to represent a group service instance. In a Spring-Boot-based microservice, the application  ID will always be the value set by the  spring.application.name property. For your eureka-client service, your  spring.application.name is creatively named eureka-client. The instance  ID will be a random number meant to represent a single service instance.</p><p><strong>NOTE</strong>  Remember that normally the  spring.application.name property<br>goes in the bootstrap.yml file. I’ve included it in the application.yml for illustrative purposes. The code will work with the  spring.application.name<br>but the proper place long-term for this attribute is the bootstrap.yml file.</p><p>The second part of your configuration provides how and where the service should register with the Eureka service. The  eureka.instance.preferIpAddress property<br>tells Eureka that you want to register the service’s  IP address to Eureka rather than its hostname.</p><p><strong>Why prefer IP address?</strong><br>By default, Eureka will try to register the services that contact it by hostname. This works well in a server-based environment where a service is assigned a DNS-backed host name. However, in a container-based deployment (for example, Docker), containers will be started with randomly generated hostnames and  no DNS entries for the containers.<br>If you don’t set the eureka.instance.preferIpAddress to true, your client<br>applications won’t properly resolve the location of the hostnames because there will be no DNS entry for that container. Setting the preferIpAddress attribute will<br>inform the Eureka service that client wants to be advertised by IP address.<br>Personally, we always set this attribute to true. Cloud-based microservices are supposed to be ephemeral and stateless. They can be started up and shut down at will.IP addresses are more appropriate for these types of services.</p><p>The  eureka.client.registerWithEureka attribute is the trigger to tell the organization service to register itself with Eureka. The eureka.client.fetchRegistry attribute is used to tell the Spring Eureka Client to fetch a local copy of the registry.Setting this attribute to true will cache the registry locally instead of calling the Eureka service with every lookup. Every 30 seconds, the client software will re-contact the Eureka service for any changes to the registry.</p><p>The last attribute, the  eureka.serviceUrl.defaultZone attribute, holds a<br>comma-separated list of Eureka services the client will use to resolve to service locations. For our purposes, you’re only going to have one Eureka service.</p><p>At this point you’ll have a single service registered with your Eureka service.<br>You can use Eureka’s  REST API to see the contents of the registry. To see all the<br>instances of a service, hit the following  GET endpoint:<br>http://<eureka service="">:8761/eureka/apps/<appid><br>For instance, to see the organization service in the registry you can call  http://<br>localhost:8761/eureka/apps/organizationservice .</appid></eureka></p><p><img src="/images/springmicroservices/springmicroc4p5.png" alt="springmicroc4p5"></p><p>The default format returned by the Eureka service is  XML . Eureka can also return the data in figure 4.5 as a  JSON payload, but you have to set the  Accept HTTP header to be  application/json . An example of the  JSON payload is shown in figure 4.6.</p><p><img src="/images/springmicroservices/springmicroc4p6.png" alt="springmicroc4p6"></p><h3 id="Using-service-discovery-to-look-up-a-service"><a href="#Using-service-discovery-to-look-up-a-service" class="headerlink" title="Using service discovery to look up a service"></a>Using service discovery to look up a service</h3><p>You now have the organization service registered with Eureka. You can also have the licensing service call the organization service without having direct knowledge of the location of any of the organization services. The licensing service will look up the physical location of the organization by using Eureka.<br>For our purposes, we’re going to look at three different Spring/Netflix client libraries in which a service consumer can interact with Ribbon. These libraries will move from the lowest level of abstraction for interacting with Ribbon to the highest.<br>The libraries we’ll explore include<br> Spring Discovery client<br> Spring Discovery client enabled RestTemplate<br> Netflix Feign client </p><p>First, I’ve modified the src/main/java/com/thoughtmechanix/licenses/controllers/LicenseServiceController.java to include a new route for the license services. This new route will allow you to specify the type of client you want to invoke the service with. This is a helper route so that as we explore each of the different methods for invoking the organization service via Ribbon, you can try each mechanism through a single route. The following listing shows the code for the new route in the LicenseServiceController class. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;licenseId&#125;/&#123;clientType&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="comment">//    The clientType determines the type of Spring REST client to use.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> License <span class="title">getLicensesWithClient</span><span class="params">( @PathVariable(<span class="string">"organizationId"</span>)</span> String organizationId,</span></span><br><span class="line"><span class="function">                                         @<span class="title">PathVariable</span><span class="params">(<span class="string">"licenseId"</span>)</span> String licenseId,</span></span><br><span class="line"><span class="function">                                         @<span class="title">PathVariable</span><span class="params">(<span class="string">"clientType"</span>)</span> String clientType) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> licenseService.getLicense(organizationId,licenseId, clientType);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In this code, the clientType parameter passed on the route will drive the type of client we’re going to use in the code examples. The specific types you can pass in on this route include<br> Discovery—Uses the discovery client and a standard Spring RestTemplate class<br>to invoke the organization service<br> Rest—Uses an enhanced Spring RestTemplate to invoke the Ribbon-based service<br> Feign—Uses Netflix’s Feign client library to invoke a service via Ribbon </p><p>In the src/main/java/com/thoughtmechanix/licenses/services/LicenseService.java class, I’ve added a simple method called retrieveOrgInfo() that will resolve based on the clientType passed into the route the type of client that will be used to look up an organization service instance. The getLicense() method on the LicenseService class will use retrieveOrgInfo() to retrieve the organization data from the Postgres database. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> License <span class="title">getLicense</span><span class="params">(String organizationId,String licenseId, String clientType)</span> </span>&#123;</span><br><span class="line">    License license = licenseRepository.findByOrganizationIdAndLicenseId(organizationId, licenseId);</span><br><span class="line"></span><br><span class="line">    Organization org = retrieveOrgInfo(organizationId, clientType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> license</span><br><span class="line">            .withOrganizationName( org.getName())</span><br><span class="line">            .withContactName( org.getContactName())</span><br><span class="line">            .withContactEmail( org.getContactEmail() )</span><br><span class="line">            .withContactPhone( org.getContactPhone() )</span><br><span class="line">            .withComment(config.getExampleProperty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Looking-up-service-instances-with-Spring-DiscoveryClient"><a href="#Looking-up-service-instances-with-Spring-DiscoveryClient" class="headerlink" title="Looking up service instances with Spring DiscoveryClient"></a>Looking up service instances with Spring DiscoveryClient</h4><p>The Spring DiscoveryClient offers the lowest level of access to Ribbon and the services registered within it. Using the DiscoveryClient, you can query for all the services registered with the ribbon client and their corresponding URLs.<br>Next, you’ll build a simple example of using the DiscoveryClient to retrieve one of the organization service URLs from Ribbon and then call the service using a standard RestTemplate class. To begin using the DiscoveryClient, you first need to annotate the src/main/java/com/thoughtmechanix/licenses/Application.java class with the @EnableDiscoveryClient annotation, as shown in the next listing. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The @EnableDiscoveryClient annotation is the trigger for Spring Cloud to enable the application to use the DiscoveryClient and Ribbon libraries.</p><p>Now, let’s look at your implementation of the code that calls the organization service via the Spring DiscoveryClient, as shown in the following listing. You can find this in<br>src/main/java/com/thoughtmechanix/licenses/OrganizationDiscoveryClient.java. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationDiscoveryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//    DiscoveryClient is auto-injected into the class.</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Organization <span class="title">getOrganization</span><span class="params">(String organizationId)</span> </span>&#123;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="comment">//        Gets a list of all the instances of organization services</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"organizationservice"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instances.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//        Retrieves the service endpoint we are going to call</span></span><br><span class="line">        String serviceUri = String.format(<span class="string">"%s/v1/organizations/%s"</span>,instances.get(<span class="number">0</span>).getUri().toString(), organizationId);</span><br><span class="line"><span class="comment">//        Uses a standard Spring REST Template class to call the service</span></span><br><span class="line">        ResponseEntity&lt; Organization &gt; restExchange =</span><br><span class="line">                restTemplate.exchange(</span><br><span class="line">                        serviceUri,</span><br><span class="line">                        HttpMethod.GET,</span><br><span class="line">                        <span class="keyword">null</span>, Organization.class, organizationId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restExchange.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The first item of interest in the code is the DiscoveryClient. This is the class you’ll use to interact with Ribbon. To retrieve all instances of the organization services registered with Eureka, you can use the getInstances() method, passing in the key of service you’re looking for, to retrieve a list of ServiceInstance objects.<br>The ServiceInstance class is used to hold information about a specific instance of a service including its hostname, port and URI.<br>In listing 4.8, you take the first ServiceInstance class in your list to build a target URL that can then be used to call your service. Once you have a target URL, you can use a standard Spring RestTemplate to call your organization service and retrieve data. </p><p><strong>The DiscoveryClient and real life </strong></p><p>I’m walking through the DiscoveryClient to be completed in our discussion of building service consumers with Ribbon. The reality is that you should only use the DiscoveryClient directly when your service needs to query Ribbon to understand what services and service instances are registered with it. There are several problems with this code including the following:<br>You aren’t taking advantage of Ribbon’s client side load-balancing—By calling the DiscoveryClient directly, you get back a list of services, but it becomes your responsibility to choose which service instances returned you’re going to invoke.<br>You’re doing too much work—Right now, you have to build the URL that’s going to be used to call your service. It’s a small thing, but every piece of code that you can avoid writing is one less piece of code that you have to debug.<br>Observant Spring developers might have noticed that you’re directly instantiating the RestTemplate class in the code. This is antithetical to normal Spring REST invocations, as normally you’d have the Spring Framework inject the RestTemplate the class using it via the @Autowired annotation.<br>You instantiated the RestTemplate class in listing 4.8 because once you’ve enabled the Spring DiscoveryClient in the application class via the @EnableDiscoveryClient annotation, all RestTemplates managed by the Spring framework will have a Ribbon-enabled interceptor injected into them that will change how URLs are created with the RestTemplate class. Directly instantiating the RestTemplate class<br>allows you to avoid this behavior.<br>In summary, there are better mechanisms for calling a Ribbon-backed service. </p><h4 id="Invoking-services-with-Ribbon-aware-Spring-RestTemplate"><a href="#Invoking-services-with-Ribbon-aware-Spring-RestTemplate" class="headerlink" title="Invoking services with Ribbon-aware Spring RestTemplate"></a>Invoking services with Ribbon-aware Spring RestTemplate</h4><p>Next, we’re going to see an example of how to use a RestTemplate that’s Ribbonaware. This is one of the more common mechanisms for interacting with Ribbon via Spring. To use a Ribbon-aware RestTemplate class, you need to define a RestTemplate bean construction method with a Spring Cloud annotation called @LoadBalanced. For the licensing service, the method that will be used to create the RestTemplate bean can be found in src/main/java/com/thoughtmechanix/licenses/Application.java. </p><p>The following listing shows the getRestTemplate() method that will create the Ribbon-backed Spring RestTemplate bean. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="comment">//    The @LoadBalanced annotation tells Spring Cloud to create a Ribbon backed RestTemplate class.</span></span><br><span class="line">  <span class="meta">@LoadBalanced</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now that the bean definition for the Ribbon-backed RestTemplate class is defined,any time you want to use the RestTemplate bean to call a service, you only need to auto-wire it into the class using it.<br>Using the Ribbon-backed RestTemplate class pretty much behaves like a standard Spring RestTemplate class, except for one small difference in how the URL for target service is defined. Rather than using the physical location of the service in the RestTemplate call, you’re going to build the target URL using the Eureka service ID of the service you want to call.<br>Let’s see this difference by looking at the following listing. The code for this listing can be found in the src/main/java/com/thoughtmechanix/licenses/clients/OrganizationRestTemplate.java class. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationRestTemplateClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Organization <span class="title">getOrganization</span><span class="params">(String organizationId)</span></span>&#123;</span><br><span class="line"><span class="comment">//        When using a Ribbon-back RestTemplate, you build the target URL with the Eureka service ID.</span></span><br><span class="line">        ResponseEntity&lt;Organization&gt; restExchange =</span><br><span class="line">                restTemplate.exchange(</span><br><span class="line">                        <span class="string">"http://organizationservice/v1/organizations/&#123;organizationId&#125;"</span>,</span><br><span class="line">                        HttpMethod.GET,</span><br><span class="line">                        <span class="keyword">null</span>, Organization.class, organizationId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restExchange.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code should look somewhat similar to the previous example, except for two key differences. First, the Spring Cloud DiscoveryClient is nowhere in sight. Second,the URL being used in therestTemplate.exchange() call should look odd to you:</p><p>restTemplate.exchange(<br>“<a href="http://organizationservice/v1/organizations/{organizationId}&quot;" target="_blank" rel="noopener">http://organizationservice/v1/organizations/{organizationId}&quot;</a>,<br>HttpMethod.GET,<br>null, Organization.class, organizationId);</p><p>The server name in the URL matches the application ID of the organizationservice key that you registered the organization service with in Eureka:<br>http://{applicationid}/v1/organizations/{organizationId}<br>The Ribbon-enabled RestTemplate will parse the URL passed into it and use whatever is passed in as the server name as the key to query Ribbon for an instance of a service. The actual service location and port are completely abstracted from the developer.<br>In addition, by using the RestTemplate class, Ribbon will round-robin load balance all requests among all the service instances. </p><h4 id="Invoking-services-with-Netflix-Feign-client"><a href="#Invoking-services-with-Netflix-Feign-client" class="headerlink" title="Invoking services with Netflix Feign client"></a>Invoking services with Netflix Feign client</h4><p>An alternative to the Spring Ribbon-enabled RestTemplate class is Netflix’s Feign client library. The Feign library takes a different approach to calling a REST service by having the developer first define a Java interface and then annotating that interface with Spring Cloud annotations to map what Eureka-based service Ribbon will invoke.The Spring Cloud framework will dynamically generate a proxy class that will be used to invoke the targeted REST service. There’s no code being written for calling the service other than an interface definition.<br>To enable the Feign client for use in your licensing service, you need to add a new annotation, @EnableFeignClients, to the licensing service’s src/main/java/com/thoughtmechanix/licenses/Application.java class. The following listing<br>shows this code. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//The @EnableFeignClients annotation is needed to use the FeignClient in your code</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now that you’ve enabled the Feign client for use in your licensing service, let’s look at a Feign client interface definition that can be used to call an endpoint on the organization service. The following listing shows an example. The code in this listing can be found in the src/main/java/com/thoughtmechanix/licenses/clients/OrganizationFeignClient.java class.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Identify your service to Feign using the FeignClient Annotation.</span></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"organizationservice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrganizationFeignClient</span> </span>&#123;</span><br><span class="line"><span class="comment">//    The path and action to your endpoint is defined using the @RequestMapping annotation.</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(</span><br><span class="line">            method= RequestMethod.GET,</span><br><span class="line">            value=<span class="string">"/v1/organizations/&#123;organizationId&#125;"</span>,</span><br><span class="line">            consumes=<span class="string">"application/json"</span>)</span><br><span class="line"><span class="comment">//    The parameters passed into the endpoint are defined using the @PathVariable endpoint.</span></span><br><span class="line">    <span class="function">Organization <span class="title">getOrganization</span><span class="params">(@PathVariable(<span class="string">"organizationId"</span>)</span> String organizationId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You start the Feign example by using the @FeignClient annotation and passing it the name of the application id of the service you want the interface to represent. Next you’ll define a method, getOrganization(), in your interface that can be called by the client to invoke the organization service.<br>How you define the getOrganization() method looks exactly like how you would expose an endpoint in a Spring Controller class. First, you’re going to define a @RequestMapping annotation for the getOrganization() method that will map the HTTP verb and endpoint that will be exposed on the organization service invocation. Second, you’ll map the organization ID passed in on the URL to an<br>organizationId parameter on the method call, using the @PathVariable annotation. The return value from the call to the organization service will be automatically mapped to the Organization class that’s defined as the return value for the getOrganization() method.<br>To use the OrganizationFeignClient class, all you need to do is autowire and use it. The Feign Client code will take care of all the coding work for you. </p><p><strong>On error handling</strong></p><p>When you use the standard Spring RestTemplate class, all service calls’ HTTP status codes will be returned via the ResponseEntity class’s getStatusCode() method. With the Feign Client, any HTTP 4xx – 5xx status codes returned by the service being called will be mapped to a FeignException. The FeignException will<br>contain a JSON body that can be parsed for the specific error message.<br>Feign does provide you the ability to write an error decoder class that will map the error back to a custom Exception class. Writing this decoder is outside the scope of this book, but you can find examples of this in the Feign GitHub repository at(<a href="https://github.com/Netflix/feign/wiki/Custom-error-handling)" target="_blank" rel="noopener">https://github.com/Netflix/feign/wiki/Custom-error-handling)</a>. </p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p> The service discovery pattern is used to abstract away the physical location of services.<br> A service discovery engine such as Eureka can seamlessly add and remove service instances from an environment without the service clients being impacted.<br> Client-side load balancing can provide an extra level of performance and resiliency by caching the physical location of a service on the client making the service call.<br> Eureka is a Netflix project that when used with Spring Cloud, is easy to set up and configure.<br> You used three different mechanisms in Spring Cloud, Netflix Eureka, and Netflix Ribbon to invoke a service. These mechanisms included<br>– Using a Spring Cloud service DiscoveryClient<br>– Using Spring Cloud and Ribbon-backed RestTemplate<br>– Using Spring Cloud and Netflix’s Feign client </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;In any distributed architecture, we need to find the physical address of where a&lt;br&gt;machine is located. This concept has been around since the beginning of distributed computing and is known formally as service discovery. Service discovery can be something as simple as maintaining a property file with the addresses of all the remote services used by an application, or something as formalized (and complicated) as a  UDDI (Universal Description, Discovery, and Integration) repository.
    
    </summary>
    
      <category term="Spring Microservices" scheme="https://hunterhdq.github.io/categories/Spring-Microservices/"/>
    
    
      <category term="Spring" scheme="https://hunterhdq.github.io/tags/Spring/"/>
    
      <category term="Spring Microservices" scheme="https://hunterhdq.github.io/tags/Spring-Microservices/"/>
    
      <category term="微服务" scheme="https://hunterhdq.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="服务发现" scheme="https://hunterhdq.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>团建后的一点心情</title>
    <link href="https://hunterhdq.github.io/2019/01/19/%E5%9B%A2%E5%BB%BA%E5%90%8E%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E6%83%85/"/>
    <id>https://hunterhdq.github.io/2019/01/19/团建后的一点心情/</id>
    <published>2019-01-19T14:02:54.000Z</published>
    <updated>2019-01-19T15:20:50.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019-1-19-随笔"><a href="#2019-1-19-随笔" class="headerlink" title="2019-1-19 随笔"></a>2019-1-19 随笔</h3><p>2019-1-19，公司集体组织团建，无非就是一伙人找个地方，吃吃饭，聊聊天，唱唱歌，玩玩游戏，本就是抱着吃一顿饭就回来的心态去的。从早上八点出发到晚上八点回来，团建总体来说很热闹，在一个别墅里面（电竞VR体验馆）30多个人，很久没有这么多人在一起了。 </p><p>回来之后，突然有一种感觉：觉得生活很无趣甚至讨厌这个浮躁的社会。可能是一下子从热闹的场景里面回到了一个人空荡的房间，孤独寂寞的感觉充斥着整个人。我以为只有我一个人有这样的想法，于是问了年长我几岁的朋友，发现他也会有这样的感觉，这样确定下来我是正常的。<a id="more"></a></p><p>2019年是崭新的一年，我静着坐下来回想了一下2018年的所得与所失。人生中在某些时候有很多种选择，不论是深造，公务员，继续工作，或者是转行创业，还是在疲惫后来一场“酣畅淋漓”的旅行，选择背后都需要付出巨大的努力。小时候会盼着快快长大于是浑浑噩噩的过日子，转眼间二十多岁又会有所恐慌，才发现时间过的如此之快，很快就会往三十上爬，很害怕到那个时候自己还是个碌碌无为的人（可能是忧虑的过早）。这个时代的年轻人背负了太多的压力，太多的责任，我们奋斗想过上更好的生活，想体现自己的价值。然而社会在有些时候却渐渐扭曲了我们的价值观，人们为着房子一生背上了沉重的房贷，为了一套房子不断去想着办法挣钱，好似大部分人都为了“钱”奋斗，现实让我们一个个成为痛苦的房奴，但却还是不断地有人去做“奴隶”。</p><p>自己觉得自己还算是个低调谦逊的人，同样自始至终都不是一个善于表达想法的人，总是习惯将一些想法藏在心里，然后通过努力一点一点去实现，成功了也就成功了也没有多少人为你喝彩，不成功那就是失败了自然也没有多少人嘲笑你。时间长了之后，可能已经没有多少人记得你了。我从来都不想在合适的时候表现自己，其实默默按着自己的想法去干一件事情挺好的，做一只小蚂蚁不亮眼，不会被大象踩死，一点点“搬运”，也会充实整个“蚂蚁家族”。我始终相信那些支持你的那些属于你的会始终在你身边，这二十多年来，觉得自己从一个“感性”的小伙逐渐变得“理性”“成熟”，再也不会依着自己的性情来做事。</p><p>今天偶然看到一篇微信推文：孤独，是人生的必修课。《百年孤独》里说：<strong>“生命从来不曾离开过孤独而独立存在。无论是我们出生、我们成长、我们相爱还是我们成功失败，直到最后的最后，孤独犹如影子一样存在于生命一隅。”</strong> 现在听着逃跑计划的《一万次悲伤》：一万次悲伤，依然会有dream，我一直在最温暖的地方等你，似乎只能这样，停留一个方向，已不能改变，每一颗眼泪，是一万道光，最昏暗的地方也变得明亮，我奔涌的暖流寻找你的海洋，我注定这样。已是23点20分，看看书，去睡觉。明天起来又会是崭新的一天。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2019-1-19-随笔&quot;&gt;&lt;a href=&quot;#2019-1-19-随笔&quot; class=&quot;headerlink&quot; title=&quot;2019-1-19 随笔&quot;&gt;&lt;/a&gt;2019-1-19 随笔&lt;/h3&gt;&lt;p&gt;2019-1-19，公司集体组织团建，无非就是一伙人找个地方，吃吃饭，聊聊天，唱唱歌，玩玩游戏，本就是抱着吃一顿饭就回来的心态去的。从早上八点出发到晚上八点回来，团建总体来说很热闹，在一个别墅里面（电竞VR体验馆）30多个人，很久没有这么多人在一起了。 &lt;/p&gt;
&lt;p&gt;回来之后，突然有一种感觉：觉得生活很无趣甚至讨厌这个浮躁的社会。可能是一下子从热闹的场景里面回到了一个人空荡的房间，孤独寂寞的感觉充斥着整个人。我以为只有我一个人有这样的想法，于是问了年长我几岁的朋友，发现他也会有这样的感觉，这样确定下来我是正常的。
    
    </summary>
    
      <category term="随笔" scheme="https://hunterhdq.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://hunterhdq.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心情" scheme="https://hunterhdq.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法之冒泡排序</title>
    <link href="https://hunterhdq.github.io/2018/10/13/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://hunterhdq.github.io/2018/10/13/经典排序算法之冒泡排序/</id>
    <published>2018-10-13T14:02:05.000Z</published>
    <updated>2019-02-13T14:07:56.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="经典排序算法之冒泡排序"><a href="#经典排序算法之冒泡排序" class="headerlink" title="经典排序算法之冒泡排序"></a>经典排序算法之冒泡排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<a id="more"></a> </p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。</p><p>第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；</p><p>第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；</p><p>依次类推，每一趟比较次数-1；</p><p>……</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hunter.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author:Hunter</span></span><br><span class="line"><span class="comment"> * Date:2018/10/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">1</span>, -<span class="number">9</span>, <span class="number">25</span>, <span class="number">88</span>, <span class="number">66</span>, <span class="number">101</span>, <span class="number">101</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    a[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;经典排序算法之冒泡排序&quot;&gt;&lt;a href=&quot;#经典排序算法之冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;经典排序算法之冒泡排序&quot;&gt;&lt;/a&gt;经典排序算法之冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h4&gt;&lt;p&gt;冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
    
    </summary>
    
      <category term="算法" scheme="https://hunterhdq.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://hunterhdq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://hunterhdq.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>经典排序算法之快速排序</title>
    <link href="https://hunterhdq.github.io/2018/10/12/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://hunterhdq.github.io/2018/10/12/经典排序算法之快速排序/</id>
    <published>2018-10-12T04:08:09.000Z</published>
    <updated>2019-02-13T14:10:39.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="经典排序算法之快速排序"><a href="#经典排序算法之快速排序" class="headerlink" title="经典排序算法之快速排序"></a>经典排序算法之快速排序</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 <a id="more"></a></p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。接着分别比较左右两边的序列，重复上述的循环。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hunter.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author:Hunter</span></span><br><span class="line"><span class="comment"> * Date:2018/10/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">12</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">23</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        quickSort(array, start, end);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = low;</span><br><span class="line">        <span class="keyword">int</span> end = high;</span><br><span class="line">        <span class="keyword">int</span> key = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &gt; start &amp;&amp; arr[end] &gt;= key) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[end] &lt;= key) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[end];</span><br><span class="line">                arr[end] = arr[start];</span><br><span class="line">                arr[start] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (end &gt; start &amp;&amp; arr[start] &lt;= key) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[start] &gt;= key) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[end];</span><br><span class="line">                arr[end] = arr[start];</span><br><span class="line">                arr[start] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; low) &#123;</span><br><span class="line">            quickSort(arr, low, start - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; high) &#123;</span><br><span class="line">            quickSort(arr, end + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;经典排序算法之快速排序&quot;&gt;&lt;a href=&quot;#经典排序算法之快速排序&quot; class=&quot;headerlink&quot; title=&quot;经典排序算法之快速排序&quot;&gt;&lt;/a&gt;经典排序算法之快速排序&lt;/h3&gt;&lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h4&gt;&lt;p&gt;通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
    
    </summary>
    
      <category term="算法" scheme="https://hunterhdq.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://hunterhdq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://hunterhdq.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(控制反转)与DI(依赖注入)--转</title>
    <link href="https://hunterhdq.github.io/2018/07/08/Spring-IOC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E4%B8%8EDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E8%BD%AC/"/>
    <id>https://hunterhdq.github.io/2018/07/08/Spring-IOC-控制反转-与DI-依赖注入-转/</id>
    <published>2018-07-08T12:18:32.000Z</published>
    <updated>2019-02-26T12:31:19.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-IOC-控制反转-与DI-依赖注入-–转"><a href="#Spring-IOC-控制反转-与DI-依赖注入-–转" class="headerlink" title="Spring IOC(控制反转)与DI(依赖注入)–转"></a>Spring IOC(控制反转)与DI(依赖注入)–转</h3><p>学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。<a id="more"></a></p><h2 id="一、分享Iteye的开涛对Ioc的精彩讲解"><a href="#一、分享Iteye的开涛对Ioc的精彩讲解" class="headerlink" title="一、分享Iteye的开涛对Ioc的精彩讲解"></a>一、分享Iteye的开涛对Ioc的精彩讲解</h2><p>　　首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：<a href="http://jinnianshilongnian.iteye.com/blog/1413846" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1413846</a></p><h3 id="1-1、IoC是什么"><a href="#1-1、IoC是什么" class="headerlink" title="1.1、IoC是什么"></a>1.1、IoC是什么</h3><p>　　<strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。</strong>在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><p>　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；<strong>谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</strong></p><p>　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？<strong>因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</strong></p><p>　　用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：<img src="/images/spring/springc1p1.jpg" alt="springc1p1"></p><p>图1-1 传统应用程序示意图</p><p>　　当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:<img src="/images/spring/springc1p2.png" alt="springc1p2"></p><p>图1-2有IoC/DI容器后程序结构示意图</p><h3 id="1-2、IoC能做什么"><a href="#1-2、IoC能做什么" class="headerlink" title="1.2、IoC能做什么"></a>1.2、IoC能做什么</h3><p>　　IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p>　　其实<strong>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</strong></p><p>　　<strong>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</strong></p><h3 id="1-3、IoC和DI"><a href="#1-3、IoC和DI" class="headerlink" title="1.3、IoC和DI"></a>1.3、IoC和DI</h3><p>　　<strong>DI—Dependency Injection，即“依赖注入”</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。<strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><p>　　●谁依赖于谁：当然是<strong>应用程序依赖于IoC容器</strong>；</p><p>　　●为什么需要依赖：<strong>应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p><p>　　●谁注入谁：很明显是<strong>IoC容器注入应用程序某个对象，应用程序依赖的对象</strong>；</p><p>　　●注入了什么：就是<strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>。</p><p>　　<strong>IoC和DI</strong>由什么<strong>关系</strong>呢？其实它们<strong>是同一个概念的不同角度描述</strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。</p><h2 id="二、分享Bromon的blog上对IoC与DI浅显易懂的讲解"><a href="#二、分享Bromon的blog上对IoC与DI浅显易懂的讲解" class="headerlink" title="二、分享Bromon的blog上对IoC与DI浅显易懂的讲解"></a>二、分享Bromon的blog上对IoC与DI浅显易懂的讲解</h2><h3 id="2-1、IoC-控制反转"><a href="#2-1、IoC-控制反转" class="headerlink" title="2.1、IoC(控制反转)"></a>2.1、IoC(控制反转)</h3><p>　　首先想说说<strong>IoC（Inversion of Control，控制反转）</strong>。这是<strong>spring的核心</strong>，贯穿始终。<strong>所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</strong>这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><p>　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。<strong>Spring所倡导的开发方式</strong>就是如此，<strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p><h3 id="2-2、DI-依赖注入"><a href="#2-2、DI-依赖注入" class="headerlink" title="2.2、DI(依赖注入)"></a>2.2、DI(依赖注入)</h3><p>　　<strong>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的</strong>。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</p><h2 id="三、我对IoC-控制反转-和DI-依赖注入-的理解"><a href="#三、我对IoC-控制反转-和DI-依赖注入-的理解" class="headerlink" title="三、我对IoC(控制反转)和DI(依赖注入)的理解"></a>三、我对IoC<strong>(控制反转)</strong>和DI<strong>(依赖注入)</strong>的理解</h2><p>　　在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p><p>　　所以<strong>控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方</strong>，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p><p>　　这是我对Spring的IoC<strong>(控制反转)</strong>的理解。DI<strong>(依赖注入)</strong>其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：<strong>控制的什么被反转了？就是：获得依赖对象的方式反转了。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring-IOC-控制反转-与DI-依赖注入-–转&quot;&gt;&lt;a href=&quot;#Spring-IOC-控制反转-与DI-依赖注入-–转&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC(控制反转)与DI(依赖注入)–转&quot;&gt;&lt;/a&gt;Spring IOC(控制反转)与DI(依赖注入)–转&lt;/h3&gt;&lt;p&gt;学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解。
    
    </summary>
    
      <category term="Spring" scheme="https://hunterhdq.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://hunterhdq.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>强引用、软引用、弱引用、幻象引用的区别</title>
    <link href="https://hunterhdq.github.io/2018/06/01/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hunterhdq.github.io/2018/06/01/强引用、软引用、弱引用、幻象引用的区别/</id>
    <published>2018-06-01T11:30:17.000Z</published>
    <updated>2019-01-21T12:43:47.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本回答"><a href="#基本回答" class="headerlink" title="基本回答"></a>基本回答</h3><p>Java中，除了基本数据类型的变量，其它所有的都是引用数据类型。不同的引用类型主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响 </strong>。</p><p>强引用（Strong Reference）,就是普通对象的引用，只要还有强引用指向一个对象，就表明这个对象还活着，那么GC就不会去触碰。对于普通对象，如果没有了其它的引用关系，只要超过了引用的作用域或显式的将强引用赋值为null，那么就是可以被GC的，回收的时机取决于垃圾回收策略。<a id="more"></a></p><p>软引用（Soft Reference），相对强引用弱化的引用。它会让垃圾收集不去触碰这些引用的对象，只有当JVM认为内存不足时，才会试图回收这些软引用所指向的对象。JVM会确保在抛出OOM错误之前，清理软引用的对象。因此，软引用通常用来实现内存敏感的缓存，如果还有内存空间，就暂时保留缓存，内存不足时就清理，保证使用缓存的同时不会耗尽内存。</p><p>弱引用（Weak Reference），并不能使对象豁免垃圾回收进行收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以构建一种没有特定约束的关系。当试图获取时对象还在，那么就使用，否则重新实例化，这种方式同样是很多缓存实现的选择。但是垃圾回收的时候会进行二次确认是否保持弱引用的情况。保持这个状态才会进行清理。</p><p>幻想引用（虚引用），你不能通过它来访问对象。幻想引用仅仅是提供一种确保对象在被finalize之后，做某些事情的机制。比如，Post-Mortem清理机制，Java平台自身的Cleaner机制等，也有人利用幻想引用监控对象的创建和销毁。</p><h3 id="一点拓展"><a href="#一点拓展" class="headerlink" title="一点拓展"></a>一点拓展</h3><p>Java平台定义的不同可达性级别（reachability level）：</p><p>1.强可达(Strongly Reachable):当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新建一个对象，那么创建它的线程对它就是强可达。</p><p>2.软可达（Softly Reachable）:当我们只能通过软引用才能访问到对象的状态。</p><p>3.弱引用（Weakly Reachable）：无法通过强引用或软引用访问，只能通过弱引用访问到的状态。十分接近finalize状态的时机，当弱引用被清除时，就符合finalize的条件。</p><p>4.幻像可达（Phantom Reachable）：没有强引用，软引用，弱引用关联，并且finalize过了，只有幻象引用指向这个对象的时候。</p><p>5.不可达（unreachable）：对象可以被清除。</p><p>说的通俗一点：</p><p>强引用就像大老婆，关系很稳固。<br>软引用就像二老婆，随时有失宠的可能，但也有扶正的可能。<br>弱引用就像情人，关系不稳定，可能跟别人跑了。<br>幻像引用就是梦中情人，只在梦里出现过。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本回答&quot;&gt;&lt;a href=&quot;#基本回答&quot; class=&quot;headerlink&quot; title=&quot;基本回答&quot;&gt;&lt;/a&gt;基本回答&lt;/h3&gt;&lt;p&gt;Java中，除了基本数据类型的变量，其它所有的都是引用数据类型。不同的引用类型主要体现的是&lt;strong&gt;对象不同的可达性（reachable）状态和对垃圾收集的影响 &lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;强引用（Strong Reference）,就是普通对象的引用，只要还有强引用指向一个对象，就表明这个对象还活着，那么GC就不会去触碰。对于普通对象，如果没有了其它的引用关系，只要超过了引用的作用域或显式的将强引用赋值为null，那么就是可以被GC的，回收的时机取决于垃圾回收策略。
    
    </summary>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/tags/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java基础" scheme="https://hunterhdq.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别</title>
    <link href="https://hunterhdq.github.io/2018/05/31/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hunterhdq.github.io/2018/05/31/String、StringBuffer、StringBuilder的区别/</id>
    <published>2018-05-31T12:09:20.000Z</published>
    <updated>2019-01-18T16:00:30.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本回答"><a href="#基本回答" class="headerlink" title="基本回答"></a>基本回答</h3><p>String是Java语言中非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是final class，即Immutable类，其所有属性都被声明为final，所以我们对String的拼接和截取等都会产生新的String对象。日常开发中，对于字符串的操作会非常多，那么String的相关操作往往会对应用性能产生明显的影响。</p><p>StringBuffer是为了解决String字符串拼接操作产生太多中间对象而提供的一个类，StringBuffer有很多方法供我们操作字符串，例如appen方法追加字符，insert方法在指定位置插入字符。它的本质是一个线程安全的可修改的字符序列，但是保证线程安全也会带来额外的性能开销，除非有线程安全的必要，否则推荐使用StringBuilder。<a id="more"></a></p><p>StringBuilder是jdk1.5中增加的，它的功能和StringBuffer没有什么区别，但是它不是线程安全的，减少了一些额外的开销，在大部分情况下我们都用它来对字符串拼接等操作。</p><h3 id="一点拓展"><a href="#一点拓展" class="headerlink" title="一点拓展"></a>一点拓展</h3><p>String是Immutable类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改。StringBuffer实现线程安全是在所有的修改数据的方法上加上synchronized关键字，简单粗暴。StringBuffer和StringBuilder本质上是privata final char[] value数组（JDK9中为byte)，二者都继承了AbstractStringBuilder，区别仅在与在方法上是否添加了synchronized关键字。Java字符串的设计者在最初就考虑到了char类型的内部数组应该创建多大最为合适。过小会导致字符串操作时会重新创建足够大的数组，过大的话就会浪费空间。目前，构建时初始长度为16，这样的大小是被认为是最合适的，避免很多次扩容产生的额外开销。扩容实际上抛弃原有数组，创建新的数组（可简单认为是倍数扩容），然后进行arraycopy。</p><p>关于String的创建机制有必要做更深层次的探究：由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例：String str1 = <span class="string">"123"</span>; <span class="comment">//通过直接量赋值方式，放入字符串常量池</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(“<span class="number">123</span>”);<span class="comment">//通过new方式赋值方式，不放入字符串常量池</span></span><br></pre></td></tr></table></figure><p>注意：String提供了intern()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。在java6历史版本中，Intern缓存的字符串存在于“永久代”中，这个空间是有限的，也基本不会被FULLGC之外的垃圾收集照顾到，如果调用太多，就会出现OOM错误。再后来的版本中，缓存被放到了堆中，避免了永久代被占满的问题，并且JDK1.8中永久代被MetaSpace（元数据区）替代。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>①在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。</p><p>②在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。</p><p>③在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本回答&quot;&gt;&lt;a href=&quot;#基本回答&quot; class=&quot;headerlink&quot; title=&quot;基本回答&quot;&gt;&lt;/a&gt;基本回答&lt;/h3&gt;&lt;p&gt;String是Java语言中非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是final class，即Immutable类，其所有属性都被声明为final，所以我们对String的拼接和截取等都会产生新的String对象。日常开发中，对于字符串的操作会非常多，那么String的相关操作往往会对应用性能产生明显的影响。&lt;/p&gt;
&lt;p&gt;StringBuffer是为了解决String字符串拼接操作产生太多中间对象而提供的一个类，StringBuffer有很多方法供我们操作字符串，例如appen方法追加字符，insert方法在指定位置插入字符。它的本质是一个线程安全的可修改的字符序列，但是保证线程安全也会带来额外的性能开销，除非有线程安全的必要，否则推荐使用StringBuilder。
    
    </summary>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/tags/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java基础" scheme="https://hunterhdq.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>final、finally、finalize有什么不同</title>
    <link href="https://hunterhdq.github.io/2018/05/16/final%E3%80%81finally%E3%80%81finalize%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/"/>
    <id>https://hunterhdq.github.io/2018/05/16/final、finally、finalize有什么不同/</id>
    <published>2018-05-16T14:25:41.000Z</published>
    <updated>2019-01-16T16:04:10.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本回答"><a href="#基本回答" class="headerlink" title="基本回答"></a>基本回答</h3><p>1.final可以用来修饰类、方法和变量。final修饰的类不可以被继承，修饰的变量不可以被修改，修饰的方法不可以被重写(Overwrite)。</p><p>2.finally表示Java保证重点代码一定要执行的一种机制。通常开发中，我们使用try-finally或者try-catch-finally来执行一些特定的操作，比如关闭JDBC的连接，关闭IO流、保证unlock锁等。<a id="more"></a></p><p>3.finalize是Java lang包下基础类Object的一个方法，它是为了保证对象在被GC前完成特定资源的回收。在jdk9中已被deprecated，不推荐使用。</p><h3 id="一点拓展"><a href="#一点拓展" class="headerlink" title="一点拓展"></a>一点拓展</h3><p>​    final是被推荐使用的，它可以明确地表示我们代码的逻辑意图，明确告知别人某些行为是不可以更改的。在java.lang包下的很多类都被声明为final class，有效避免API使用者更改基础功能，保证平台安全。使用final修饰参数或变量，可以避免意外赋值导致的编程bug。并且final变量可以用于保护只读数据，在并发编程中，明确不能再赋值final变量，有利于减少额外的同步开销，省去一些防御性拷贝的必要。那么final是不是immutable（不可变）呢？其实不然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       list.add(<span class="string">"single"</span>);</span><br><span class="line">       list.add(<span class="string">"dog"</span>);</span><br><span class="line">       list.add(<span class="string">"is pretty good"</span>);</span><br><span class="line">       System.out.println(list);</span><br></pre></td></tr></table></figure><p>final约束的是list这个引用不可以被赋值，但是这个对象的行为不受final影响，不论是添加还是删除元素都是可以的。</p><p>​    finally相信每一个Java开发者都知道怎么使用。其实在jdk7的版本就推出了try-catch-resources，我们可以使用它来更好地处理异常，减少我们一些重复的关闭资源的动作。特别要注意的是，finally里的代码在有一种情况下不会执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    finalize业界不推荐使用，我们无法使用finalize保证特定资源的回收，finalize具体在什么时候执行，是否符合我们的需求这些都是无法预知的。使用不当会导致程序死锁等。finalize是被设计在对象被垃圾收集前调用，那么JVM需要对finalize方法的对象进行额外的处理，本质上是快速回收的障碍者，可能导致你的对象经过多个垃圾收集周期才被回收。finalize拖慢垃圾回收，导致大量对象堆积，进一步导致OOM错误。所以资源用完就显式释放，或利用资源池来尽量reuse。目前Java正在用Cleaner来代替finalize，笔者能力有限，这里不做多说，有兴趣的可以多了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本回答&quot;&gt;&lt;a href=&quot;#基本回答&quot; class=&quot;headerlink&quot; title=&quot;基本回答&quot;&gt;&lt;/a&gt;基本回答&lt;/h3&gt;&lt;p&gt;1.final可以用来修饰类、方法和变量。final修饰的类不可以被继承，修饰的变量不可以被修改，修饰的方法不可以被重写(Overwrite)。&lt;/p&gt;
&lt;p&gt;2.finally表示Java保证重点代码一定要执行的一种机制。通常开发中，我们使用try-finally或者try-catch-finally来执行一些特定的操作，比如关闭JDBC的连接，关闭IO流、保证unlock锁等。
    
    </summary>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/tags/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java基础" scheme="https://hunterhdq.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>说说对于Java的理解</title>
    <link href="https://hunterhdq.github.io/2018/05/10/%E8%AF%B4%E8%AF%B4%E5%AF%B9%E4%BA%8EJava%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://hunterhdq.github.io/2018/05/10/说说对于Java的理解/</id>
    <published>2018-05-10T10:00:43.000Z</published>
    <updated>2019-01-15T15:21:15.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本回答"><a href="#基本回答" class="headerlink" title="基本回答"></a>基本回答</h3><p>​    Java是一门面向对象的语言，它主要有两个重要的特性。一是优秀的跨平台能力，就如官方所说的”write once,run anywhere”（书写一次，到处运行），二是Java中的GC(Garbage Collection)机制,Java通过垃圾收集器（Garbage Collector）回收分配内存，一般情况下，程序员不需要自己关心内存的分配和回收。</p><p>​    同时，Java日常开发中最常用到的就是JDK和JRE。其中JRE即Java的运行环境，包含了JVM和Java的类库等，JDK包括了JRE，它相比JRE提供了更多的工具，如编译器，Jconsole…<a id="more"></a></p><p>​    Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。<br>​    严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。“一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。Java虚拟机和DOS类似，相当于一个供程序运行的平台。“到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。    </p><h3 id="一点拓展"><a href="#一点拓展" class="headerlink" title="一点拓展"></a>一点拓展</h3><p>​    日常开发中，我们的Java代码会通过Javac编译成字节码，运行时，通过JVM内嵌的解释器将字节码转换成为最后的机器码。<img src="/javainterview/javai1p1.png" alt="java01"></p><p>​    在我们大部分开发中用的JVM中，Oracle JDK 提供的 Hotspot JVM，都提供JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，能将运行时的一部分热点代码翻译成机器码（编译执行），所以Java并不完全是解释执行的语言。</p><p>​    Java在编译期生成.class文件，通过JVM和字节码屏蔽了操作系统和硬件的细节。在运行时通过class-loader加载字节码，解释或编译执行，在JDK1.8中就是解释和编译混合的模式（-Xmixed）。</p><p>​    下图是摘自极客时间@Java核心技术36讲 杨晓峰前Oracle首席工程师总结的Java平台相对宽泛的蓝图：</p><ul><li><p><img src="https://static001.geekbang.org/resource/image/20/32/20bc6a900fc0b829c2f0e723df050732.png" alt="Java平台"></p><p>大家可以据此更深层次的了解Java这门古老的语言。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本回答&quot;&gt;&lt;a href=&quot;#基本回答&quot; class=&quot;headerlink&quot; title=&quot;基本回答&quot;&gt;&lt;/a&gt;基本回答&lt;/h3&gt;&lt;p&gt;​    Java是一门面向对象的语言，它主要有两个重要的特性。一是优秀的跨平台能力，就如官方所说的”write once,run anywhere”（书写一次，到处运行），二是Java中的GC(Garbage Collection)机制,Java通过垃圾收集器（Garbage Collector）回收分配内存，一般情况下，程序员不需要自己关心内存的分配和回收。&lt;/p&gt;
&lt;p&gt;​    同时，Java日常开发中最常用到的就是JDK和JRE。其中JRE即Java的运行环境，包含了JVM和Java的类库等，JDK包括了JRE，它相比JRE提供了更多的工具，如编译器，Jconsole…
    
    </summary>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://hunterhdq.github.io/tags/Java/"/>
    
      <category term="Java面试" scheme="https://hunterhdq.github.io/tags/Java%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java基础" scheme="https://hunterhdq.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
